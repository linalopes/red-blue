import { safeParseUrl } from "@tldraw/utils";
const importsRegex = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi;
const fontFaceRegex = /@font-face\s*{([^}]+)}/gi;
const urlsRegex = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi;
const fontFamilyRegex = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function parseCssImports(css) {
  return Array.from(css.matchAll(importsRegex), (m) => ({
    url: m[1] || m[2] || m[3] || m[4] || m[5],
    extras: m[6]
  }));
}
function parseCssFontFaces(css, baseUrl) {
  return Array.from(css.matchAll(fontFaceRegex), (m) => {
    const fontFace = m[1];
    const urls = Array.from(fontFace.matchAll(urlsRegex), (m2) => {
      const original = m2[1] || m2[2] || m2[3];
      return {
        original,
        resolved: safeParseUrl(original, baseUrl)?.href ?? null
      };
    });
    const fontFamilies = new Set(
      Array.from(fontFace.matchAll(fontFamilyRegex), (m2) => (m2[1] || m2[2] || m2[3]).toLowerCase())
    );
    return { fontFace, urls, fontFamilies };
  });
}
function parseCssFontFamilyValue(value) {
  const valueRegex = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi;
  const separatorRegex = /\s*,\s*/gi;
  const fontFamilies = /* @__PURE__ */ new Set();
  while (true) {
    const valueMatch = valueRegex.exec(value);
    if (!valueMatch) {
      break;
    }
    const fontFamily = valueMatch[1] || valueMatch[2] || valueMatch[3];
    fontFamilies.add(fontFamily.toLowerCase());
    separatorRegex.lastIndex = valueRegex.lastIndex;
    const separatorMatch = separatorRegex.exec(value);
    if (!separatorMatch) {
      break;
    }
    valueRegex.lastIndex = separatorRegex.lastIndex;
  }
  return fontFamilies;
}
function shouldIncludeCssProperty(property) {
  if (property.startsWith("-")) return false;
  if (property.startsWith("animation")) return false;
  if (property.startsWith("transition")) return false;
  if (property === "cursor") return false;
  if (property === "pointer-events") return false;
  if (property === "user-select") return false;
  if (property === "touch-action") return false;
  return true;
}
function parseCss(css, baseUrl) {
  return {
    imports: parseCssImports(css),
    fontFaces: parseCssFontFaces(css, baseUrl)
  };
}
function parseCssValueUrls(value) {
  return Array.from(value.matchAll(urlsRegex), (m) => ({
    original: m[0],
    url: m[1] || m[2] || m[3]
  }));
}
const currentColorProperties = /* @__PURE__ */ new Set([
  "border-block-end-color",
  "border-block-start-color",
  "border-bottom-color",
  "border-inline-end-color",
  "border-inline-start-color",
  "border-left-color",
  "border-right-color",
  "border-top-color",
  "caret-color",
  "column-rule-color",
  "outline-color",
  "text-decoration",
  "text-decoration-color",
  "text-emphasis-color"
]);
function isPropertyCoveredByCurrentColor(currentColor, property, value) {
  if (currentColorProperties.has(property)) {
    return value === "currentColor" || value === currentColor || property === "text-decoration" && value === `none solid ${currentColor}`;
  }
}
const inheritedProperties = /* @__PURE__ */ new Set([
  "border-collapse",
  "border-spacing",
  "caption-side",
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color',
  "cursor",
  "direction",
  "empty-cells",
  "font-family",
  "font-size",
  "font-style",
  "font-variant",
  "font-weight",
  "font-size-adjust",
  "font-stretch",
  "font",
  "letter-spacing",
  "line-height",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "list-style",
  "orphans",
  "overflow-wrap",
  "quotes",
  "stroke-linecap",
  "stroke-linejoin",
  "tab-size",
  "text-align",
  "text-align-last",
  "text-indent",
  "text-justify",
  "text-shadow",
  "text-transform",
  "visibility",
  "white-space",
  "white-space-collapse",
  "widows",
  "word-break",
  "word-spacing",
  "word-wrap"
]);
function isPropertyInherited(property) {
  return inheritedProperties.has(property);
}
export {
  isPropertyCoveredByCurrentColor,
  isPropertyInherited,
  parseCss,
  parseCssFontFaces,
  parseCssFontFamilyValue,
  parseCssImports,
  parseCssValueUrls,
  shouldIncludeCssProperty
};
//# sourceMappingURL=parseCss.mjs.map
